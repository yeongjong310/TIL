# 6. 데이터 타입
## null
- 빈값을 의미하기 때문에 undefined와는 그 의미와 쓰임이 완전히 다르다.
- GC의 대상이 되도록 하기위해 사용하기도 함.
- `보통 어떤 값을 찾으러 갔다가 반환할 때 그 값이 없는 경우라면 null을 반환한다. (반환시 null을 자주 사용하는 편)`

## undefined:
초기화를 하지 않았을 때 에러가 뜨지 않도록 하기 위해, `undefined` 타입을 만들어서 무조건 초기화 해주는 목적

## 데이터 타입이 필요성
- 변수에 값을 할당하기 전 공간을 확보할 때 바이트를 확보하는 기준: 데이터 타입의 크기만큼
- 변수에 값을 참조할 때 주소를 기준으로 몇 바이트를 가져와야 하는가? : 데이터 타입의 크기만큼
- 2진수로 표기된 값을 어떤 타입으로 해석할 것인가? A는 아스키코드로 65다. 데이터 타입이 문자인 경우 숫자 65가 아니라 문자 A로 해석해야 한다.


# 10. 동적 타이핑( 타입을 동적으로 결정한다 )
- 사용하기 쉽지만, 신뢰성이 떨어진다.

> typescript는 정적으로 변수에 타입을 명시하여 신뢰성이 높다.
> 타입을 모르기 때문에 에디터의 도움을 받기도 쉽지 않다.(코드 어시스턴스 등)

> 재할당을 하면 오류가 발생할 확률이 생긴다. 가능하면 재할당을 하지않는 습관을 가지자.
> 변수를 선언할 때 변수를 꼭 선언해야하는가 생각하고 코딩하라.

## type of 연산자 => 타입을 반환해준다. function이 아니다.
주의
1. null 타입을 object로 명시한다. (실제 타입은 null)
2. function 타입을 function으로 명시한다. (실제 타입은 object)

## **변수사용시 주의사항**

- 꼭 필요한 경우에만 변수를 사용한다.
- 변수의 유효범위를 최대한 좁게 만든다.
- 전역 변수는 지양한다.
- 상수를 사용해 변수의 재할당을 제한한다. (const, let 순으로 생각해보기) 꼭 let을 써야하나?
- 적절한 네이밍. 가능하면 명확하게



### 추가내용
`한줄로 표기하는 것이 유의미한 이유`: 변수의 유효범위가 함수단위로 동작하기 때문에 에로우 펑션같은 단축기법을 사용한다. 이 경우 스코프가 그 한줄에 속하기 때문에 Scope가 생겼다가 바로 사라진다. GC에게 유리하다. => 함수를 최대한 한가지 일만 하도록 만들며 짧은 줄로 만들자.

함수형 패러다임: 매개변수로 함수를 받는 형태(콜백) => 이떄 `변수는 항상 조심해야함 변수에서 오류가 발생한다.`

변수의 재할당에서 안티패턴에 주의해야한다. => 재할당해서 변수의 의미가 변하면 안티패턴

```js
var foo;
console.log(typeof foo);  // undefined

foo = 3;
console.log(typeof foo);  // number

foo = 'Hello';
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean

foo = null;
console.log(typeof foo);  // object

foo = Symbol(); // 심벌
console.log(typeof foo);  // symbol

foo = {}; // 객체
console.log(typeof foo);  // object

foo = []; // 배열
console.log(typeof foo);  // object

foo = function () {}; // 함수
console.log(typeof foo);  // function
```

> 리펙토링2 (마틴 파울러) javascript 책 읽어보자.

> `null`을 재할당해서 garbage collection(gc)의 대상이 된다는 말은
> null을 할당하는 순간 기존 메모리 공간을 가리키던 변수가 다른 공간을 가리키기 때문에 기존 공간의 데이터는 GC의 대상이된다. 즉 JS엔진 입장에서 점유하고있던 메모리를 해제하여 메모리 공간을 확보하는 개념이다.
> 이때 null을 재할당하는 순간에도 새로운 공간을 확보하기 때문에 실질적으로 어떤 공간을 확보하는 효과가 있을까 의문이 들지만, 리스트처럼 데이터의 크기가 큰 경우에 사용하게 되면 많은 메모리를 확보할 수 있기 때문에 유용할 수 있다.