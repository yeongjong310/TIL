# ch11. 원시값과 객체의 비교

요약
1. 원시타입 값은 변경이 불가능하다. 반면 객체는 변경할 수 있다.
2. 원시값을 변수에 할당하면 실제 값이 저장되지만, 객체를 변수에 할당하면 참조값(주소)가 저장된다.
3. 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다(값에 의한 전달). 반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다(참조에 의한 전달).

## 1. 원시값


### 1.1 변경 불가능한 값(immutable value)
- **원시 타입(primitive type)의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다.** 
  - 핵심: 메모리 주소가 바뀌는가? 안바뀌는가?
  - 한번 생성된 값은 읽기 전용 값으로서 변경할 수 없다라는 뜻이며 상수의 개념과 혼통해서는 안된다.
  - 상수는 재할당이 불가능한 변수로 한번 변수에 값이 할당되면 다른 값으로 재할당이 불가능 하다는 의미이다.
  - 값을 변경할 수 없다는 말은, 값 자체를 말하는 의미이다. => `어떤 장점이 있을까?`
    - 변수의 값이 변하면 상태 변경을 추적하기 어렵다. 

### 1.2. 문자열과 불변성
- 데이터 타입에 의해 메모리 공간을 필요한 만큼만 확보할 수 있다. 단, ECMAScript에서는 문자열 타입(2byte)와 숫자 타입(8byte) 이외의 원시 타입은 크기를 명확히 규정하고 있지 않아 브라우저마다 다를 수 있다.

- 문자열의 경우 길이에 따라서 유동적으로 크기가 바뀐다. 따라서 C언어에서는 배열의 형태로 크기를 정적으로 지정해서 문자열을 할당한다. js에서는 이런한 불편한 점을 개선하기 위해 꺼구로 유동적으로 입력된 문자열의 크기에 맞춰 데이터의 크기를 결정한다.
- 문자열의 연산은 불변을 유지하기 위해 새로운 문자열을 생성하여 새로 확보한 메모리에 할당한다.
- 문자는 유사배열객체이기 때문에 인덱스로 각 문자에 접근할 수 있다. 다만 `불변`이기 때문에 `재할당`을 할 수 없다.

#### 문자열이 불변일 때의 장점
- 타언어는 문자열의 크기가 고정되어있지 않다는 이유로 문자열을 배열(c) 혹은 객체(java-string)로서 지원한다. 이 때 개발자가 배열의 크기를 직접 입력해줘야 하거나, 원본값이 변할 위험이 있다.
- 하지만 js는 문자열이 불변이기 때문에, 문자열의 크기가 변해야할 때 새로운 값을 새로운 공간에 할당한다. 즉, 문자열을 쉽게 사용할 수 있고, 원본이 변하지 않기 때문에 JS의 장점이라고 볼 수 있다.

```js
var str = 'string';
str[0] = 'S';
console.log(str); // string
```

### 1.3. 값에 의한 전달
- x변수에 y변수를 할당할 때, 값 자체를 복사해서 새로운 메모리에 할당한다.
- 즉 x변수와 y변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
- `var x = 10;`이라는 할당문을 보고, 혼동하면 안되는 개념이 있다. 이 문은 10이라는 값을 메모리에서 생성하거나 참조하고 할당된 메모리의 주소를 반환하여 식별자 x는 실질적으로 주소를 가리키게 된다. 즉 값에 의한 전달은 메모리 상에서 값을 확인하고 주소를 전달한다는 개념이라고 보면된다.
- 중요한 것은 서로 다른 원시값은 무조건 다른 메모리 공간에 할당되어 어느 한쪽에서 `재할당`으로 `값`을 `변경`하더라도 `다른 쪽`을 `간섭`할 수 없다는 것이다.

## 2. 객체
- 원시값과 다르게 사전에 공간의 크기를 정할 수 없다. 객체라는 자료구조가 원시값과 비교해서는 복잡하기 때문에 객체를 생성하고 프로퍼티에 접근하는 것 자체도 비용이 많이드는 일이다. 

- 해시테이블과 비슷하게 동작한다고 생각하자.
- 일반적인 클래스 기반의 객체와 비교해서 동적으로 객체에 프로퍼티를 생성하고 삭제할 수 있다. 이것은 비교적 고비용의 비효율적인 방식으로 v8은 c++객체의 프로퍼티에 접근하는 정도의 효율성을 보장하기 위해 동적 탐색방식이 아닌 `히든클래스` 방식을 사용한다.

## 2.1. 변경 가능한 값
- 객체를 변수에 할당하면 실질적으로 다른 메모리 공간에 객체가 저장되고 그 공간의 주소가 변수에 저장된다.
  - 이유는, 객체를 생성하는 것이 비용이 많이드는 일이기 때문에 프로퍼티를 변경할 때 마다, 원시값 처럼 새로운 객체를 생성하지 않고, 내부적으로 필요한 프로퍼티만 변경하도록 설계한 것이다.
  - 이러한 구조의 단점은 여러 변수가 하나의 객체를 가리킬 수 있어서 `복사되었다고 착각`할 수 있다는 점이다. 나중에 생성한 변수 식별자를 통해 프로퍼티를 변경한 경우, 기존에 생성한 변수도 `같은 객체`를 가리키기 때문에 개발자의 입장에서는 의도치 않게 `원본을 수정`하게 된 것이다.

### 2.1.1 얕은 복사
변수가 가리키는 객체는 달라지지만 내부 객체들은 같은 주소를 공유한다.
> 참고: x = y 처럼 복사가 일어나지 않는 경우도 얕은 복사라고 하기도 한다.
```js
const o = {
  a: {
    b: 2
  },
  f() {}
};

// ... 스프레드 문법
let c= {...0}

// Object.assign
c = Object.assign({}, o);
```
### 2.1.2. 깊은 복사
변수가 가리키는 객체도 달라지고, 내부 객체들도 모두 다른 객체다.

```js
// JSON.stringigy로 json화 하고 parse로 분석한다.
// 단, stringify는 메소드는 복사하지 않기 때문에 사라진다.
c = JSON.parse(JSON.stringify(o));

// lodash를 사용 npm instll lodash
const _ = require('lodash');
c = _.cloneDeep(o);
```

### 2.2. 참조에 의한 전달

실질적으로 JS에서 변수에 변수를 할당하면 모두 값에 의한 전달을 한다. 무슨 뜻이냐면, 변수에 값으로 참조값(주소)이 저장되어있는지 혹은 원시값이 저장되어 있는지에 따라 그 값을 복사해서 전달하는 개념이다. 다만 그 개념을 구분하기 위해서 값에 의한 전달을 원시값을 전달하는 경우로 한정하고, 참조에 의한 전달을 참조값에 경우로 한정한다.


## 3. 원시값과 객체의 차이
원시값은 불변이다. 변수에 다른 변수를 할당할 경우, 서로 다른 메모리공간을 바라보기 때문에 어느쪽의 변수를 재할당해도 서로 간섭하지 않는다. 반면 객체의 경우 변할수 있는 값으로, 변수에 변수를 할당하면 같은 메로리공간을 바라보며 한쪽의 변수를 통해 객체의 프로퍼티를 수정하면, 다른 변수도 같은 곳을 바라보기 때문에 간섭현상이 일어난다. 의도치 않게 원본이 수정될 수 있다는 의미가 된다.

### 3.1. 객체의 문제점 해결 방안

깊은 복사를 통해 새로운 메모리 공간에 동일한 객체 값을 할당하고, 값을 수정하면 간섭현상이 일어나지 않는다.