# 변수
## 1. 변수란 무엇인가? 왜 필요한가?

실질적으로는 데이터 `입력받고 처리`하는 것이 전부인 `프로그램`에서 데이터를 효율적으로 관리하기 위한 핵심 메커니즘이 바로 변수이다.

사람은 `10 + 20` 연산을 처리하기 위해 두뇌에서 기억하고 있던 기호들을 꺼내어 문장의 의미를 해석한다. 그리고 `+` 기호의 의미인 좌측 피연산자와 우측 피연산자를 더하는 과정을 통해 `30`을 도출하고 다시 두뇌에 저장한다.

JS엔진(컴퓨터)도 두뇌라는 하나의 기관에서 모든 것을 처리하지 않을 뿐 사람이 처리하는 방식과 유사하게 동작한다. 먼저 JS엔진이 `10 + 20`이라는 식을 해석하고, `+` 연산을 위해 좌, 우측 피연산자를 메모리에 저장한다. 그리고 CPU는 메모리에서 두 데이터를 꺼내어 더하기 연산을 수행한 후 결과값 `30`을 다시 메모리에 저장한다.

### 메모리

메모리는 `데이터를 저장`할 수 있는 `메모리 셀`의 집합체이다. 하나의 메모리 셀은 `1byte(8bit)`로 이루어져 있으며, 이 단위는 데이터의 저장 단위 이기도 하다. 각 셀은 고유의 메모리 주소를 가지고 있으며, 이 메모리 주소는 메모리의 크기만큼 표현된다.

한가지 기본적이지만 중요한 사실은 이미지, 숫자, 텍스트 등 데이터의 타입과 상과없이 모든 데이터는 `2진수인 0과 1`로써 임의의 메모리 셀에 저장된다. 

### 데이터 재사용
계산된 값을 `재사용` 해야하는 경우에 메모리 주소를 통해 데이터를 찾아야 하는데, 이렇게 `직접적`으로 `메모리 공간을 제어`하게 되면 `의도치 않은 결과`를 야기할 수 있다. 가령 실수로, 운영체제가 사용중인 메모리를 삭제하거나, JS에서도 개발자 권한 밖의 중요한 핵심 데이터를 삭제할 수 있기 때문이다. 따라서 JS는 개발자가 `기억하고 싶은 메모리를 저장`하고, `저장`된 `값`을 `읽어`들여 `재사용`하기 위해 **`변수`** 라는 메커니즘을 제공한다.

### 변수의 정의
**변수란 하나의 `값`을 저장하기 위해 `확보한 메모리 공간` 자체 혹은 그 `메모리 공간`을 `식별`하기 위해 붙인 `이름`을 말한다.**

개발자가 작성한 변수이름을 사용해 `참조`를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환하는 방식이다.

### 용어
할당: 변수에 값을 저장하는 것
참조: 저장된 값을 읽어들이는 것
식별자(변수 이름): 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
변수 값: 변수에 저장된 값

## 2. 식별자(변수 이름)
어떤 값을 구별해서 `식별`할 수 있는 `고유한 이름`이다.
실제로 이 식별자는 값이 저장된 메모리 주소와 맵핑되어있다. 즉 메모리 주소에 붙인 이름이라고 할 수 있다.

`result(식별자) -> 0x0669F913(메모리 주소) -> 30(메모리)`

식별자라는 용어는 변수 이름에만 국한된 것이 아니라 클래스, 함수, 변수를 담고있는 모든 것이 식별자다. 함수 이름으로는 메모리 상에 존재하는 함수(자바스크립트는 함수도 값)를 식별할 수 있다.
```js
function foo(){
  ...
}
foo(); // foo라는 식별자를 통해 함수(값) foo을 참조한다.
```
### 용어
선언(declaration): 자바스크립트 엔진에 식별자의 존재를 알리는 행위

## 3. 변수 선언
변수 선언이란 변수를 생성하는 것을 말한다.

1. 값을 저장하기 위한 메모리 공간을 확보
2. `변수 이름`과 `확보된 메모리 공간`의 `주소`를 `연결`해서 값을 `저장할 수 있게 준비`

> 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 이전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되기 때문에 매우 안전하다.


## var(변수 선언 키워드)
단점: 블록 스코프를 지원하지 않고 함수 스코프를 지원함 이것은 세부적으로 변수의 쓰임을 제한하고 싶을 때 반듯이 함수를 사용해야하는 단점으로 다가옴.

## 선언 구문
```js
var score; // 변수 선언문
```
위 변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
실질적으로 메모리 공간에는 `undefined`라는 값이 암묵적으로 할당되며 이것은 변수가 아직 정의되지 않았다는 의미로 통한다.

## 변수 선언 단계
JS엔진은 변수를 두단계에 걸처 선언한다.

1. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undegined`를 할당해 초기화한다.

> 변수 이름이 등록되는 공간은 실행 컨텍스트
> 실행 컨텍스트란 JS 엔진이 소스코드를 평가하고, 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. JS 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

var 키워드를 사용한 변수 선언은 `선언`, `초기화`를 동시에 진행한다. 

- JS엔진에 변수를 알린다.
- 변수가 가리키는 메모리에 `undefined`가 할당된다.
    - 초기화를 거치기 때문에 쓰레기 값을 참조할 수 있는 위험으로 부터 안전하다.

>ReferenceError: 선언하지 않은 변수를 참조하려고 했을때 발생하는 에러

## 4. 변수 선언의 실행 시점과 호이스팅

```
console.log(bar); // undefined

var score; // 변수 선언문
```
변수를 참조하는 코드가 변수를 선언하는 코드보다 앞 줄에 위치하더라도 `RefferenceError`가 발생하지 않고 `undefined`를 출력한다. 그 이유는 변수의 선언과정이 코드가 `실행되는 시점`(runtime)이 아닌, 그 이전 단계에서 실행되기 때문이다. 

Js 엔진은 소스코드를 실행하기 앞서 `소스코드 평가 과정`을 거친다. 이때 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행하게 된다. 따라서 실제로 코드가 실행되는 시점(runtime)에는 모든 변수가 선언되어 있기 때문에 위와 같이 `undefined`를 출력하는 것이다.

> var 키워드를 사용해 변수를 선언하면 스코프 내에서 선언의 위치와 상관없이 어디서든 변수를 참조할 수 있다.

이처럼 변수의 선언문이 코드의 앞단으로 끌어 올려진 듯한 JS의 특징을 `호이스팅`이라고 한다.

> note: 모든 선언문은 런타임 이전 단계에 실행되기 때문에 `var, let, const, functoin, function*, class`키워드를 사용해서 선언하는 모든 식별자(변수 함수 클래스 등)는 전부 호이스팅 된다.

### 용어
키워드: JS 엔진이 수행할 동작을 규정한 일종의 명령어. JS엔진이 키워드를 만나면 약속된 동작을 수핸한다. `var`의 경우 뒤따라 적힌 이름으로 새로운 변수를 선언한다.

## 5. 값의 할당
할당 연산자(`=`)를 사용해 `우변의 값`을 `좌변의 변수`에 할당할 수 있다.

1. 변수 선언과 할당의 분리
```
var score; // 변수 선언
score = 80;
```

2. 변수 선언과 할당을 한번에
```
var score = 80; // 변수 선언과 값의 할당
```

위 두가지 타입의 코드는 정확히 동일하게 동작한다.
변수 선언과 할당을 동시에 하더라도, 변수의 선언은 코드가 실행되기 이전에 먼저 실행되며 값의 할당은 실행 시점(runtime)에 실행된다.

> 주의: 변수에 값을 할당할 때 초기화 되었던 메모리 공간을 덮어쓰는 것이 아니라 새로운 메모리 공간에 값을 저장한다.

## 6. 값의 재할당
재할당이란 이미 값이 할당된 변수에 값을 다시 할당하는 것을 말한다.
```
var foo = 80; // 변수 선언과 값의 할당
foo = 90;     // 변수 재할당
```

> 변수와 달리 저장된 값을 다른 값으로 변경하지 못하는 저장 공간을 상수라고 한다. ES6에서 도입된 `const` 키워드를 통해 재할당이 금지된 상수를 선언할 수 있다. 

> 재할당도 할당과 마찬가지로 기존에 변수가 할당되어있던 주소에 새로운 값을 덮어 쓰는 것이 아닌, 새로운 메모리 공간을 확보하고 변수와 그 공간의 주소를 맵핑하므로써 값을 할당한다.

> 가비지 콜렉터: 재할당 이후 기존 값을 저장하고있는 메모리공간은 어떤 식별자도 참조하지 않는 사용하지 않는 공간이다. 이 공간은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다. 단 알고리즘에 따라 다르기 때문에 언제 해제될지는 미지수.

> 언매니지드 언어, 매니지드 언어
> 가비지콜렉터를 사용해 메모리 누수를 방지하는 언어를 매니지드 언어라고한다. 반면 c언어 처럼 메모리를 직접적으로 할당하고 해제할 수 있는 언어를 언매니지드 언어라고한다. 언매니지드 언어의 장점은 개발자의 역량에 따라 메모리를 가장 효율적으로 사용할 수 있다는 점있다. 단점은 그 반대로 개발자가 메모리를 효율적으로 사용하지 가비지컬렉터에게 메모리 관리를 맡기는 것이 효율적일 수 있다. 매니지드 언어의 장점은 개발자의 역량이 작아지기 때문에 생산성을 확보할 수 있지만 `메모리측면`에서 `어느 정도는 손실`을 `감안`해야 한다.

## 7. 값의 교환
```js
var x = 1;
var y = 2;

// 1번 temp 변수를 새로 선언
// var temp = x
// x = y;
// y = temp;

// 2번 []으로 감싸주기
// [x, y] = [y, x]

console.log(x, y); // 2 1
```

## 8. 식별자 네이밍 규칙
- 숫자, 언더스코어(_), 달러 기호($)로 시작하는 변수를 선언할 수 있다.
- 예약어는 `strict mode`에서 식별자로 사용할 수 없다.

> 예약어
> await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* switch this throw true try typeof var void while with yield*

- 별도의 주석이 필요하다면 적합한 변수의 이름이 아닐 수 있다.
- 네이밍 컨벤션을 지켜서 사용하면 읽기 좋은 코드를 만들 수 있다.

```
카멜케이스(변수, 함수)
var firstName;

스네이크 케이스(생성자 함수, 클래스 이름)
var first_name;

파스칼케이스
var FisrtName;
```




## 기술의 부재(다음에 학습할 개념)
