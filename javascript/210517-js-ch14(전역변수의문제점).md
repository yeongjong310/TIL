# ch14. 전역 변수의 문제점

## 1. 생명 주기(life cycle)
변수는 선언되고 소멸할 때까지 생명 주기를 갖는다.
전역변수의 경우 애플리케이션의 생명 주기와 같다. 반면 지역변수는 함수가 호출된 시점에 생성디고 종료된 시점에 소멸한다.

### 1.1. 지역변수의 생명 주기 예시
```js
function foo(){
  var x = 'local'; //2 var x; //3 x = 'local'
  console.log(x); // 4
  return x // 5
}
foo(); // 1
```
1. 함수 foo를 호출한다.
2. 지역 변수 x를 선언한다.
3. 지역 변수 x에 값('local')을 할당한다.
4. x를 console에 기록한다.
5. return 문을 통해 x를 반환한다.
6. `함수가 종료`되며 지역변수 `x`도 소멸한다.

지역변수는 함수가 종료되며 함께 소멸되는 것이 일반적이지만, 클로저와 같은 특성을 생각해보면 꼭 그렇지는 않다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체다., **변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점**이라고 말하는 것이 가장 명확하다.

#### 1.1.1 지역변수의 호이스팅
지역변수의 경우 전역변수와 달리 런타임 이전 단계에 선언되지 않는다.
그럼에도 함수 스코프 내에서 지역변수의 호이스팅이 발생하는 이유는, 함수가 호출될 때 `선언부`를 `가장 먼저 실행`하기 때문이다.
위 개념에 의해 **`호이스팅`이 `스코프 단위`로 동작한다**는 점을 알 수 있다.
#### 1.1.2 호이스팅이 스코프 단위로 동작함의 예시
```js
var x = 'global'

function foo() {
  console.log(x); // ?
  var x = 'local';
}

foo();
console.log(x) // global
```

함수 내부에서 선언된 x를 console로 확인해보면 어떤 값을 출력할까? x를 참조할 때 스코프 체인에 의해 global 스코프를 찾아가서 'global'을 출력할까? 

답은 `undefined`를 출력한다. 그 이유는 foo 함수가 호출되는 시점에 변수의 선언부만 모아서 먼저 실행하기 때문이다.(전역변수와 같은 원리) 즉, 함수의 몸체가 실행되는 런타임 시간에는 지역변수에 값이 할당되기 전까지 `undefined`로 초기화된 상태를 유지한다.

### 1.2. 전역 변수의 생명 주기
전역코드는 진입점이 없다. => 코드가 로드되면 곧바로 해석되고 실행된다.
전역 변수는 전역 객체의 프로퍼티가 된다. 즉 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다. 이 말은 브라우저 환경에서 전역 객체는 window이기 때문에 var키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 된다. 

- `전역 객체 window는 웹페이지를 닫기 전까지 유효하다`.
- `var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.`

```
전역객체(global obect)

전역 객체는 자바스크립트 앤진에 의해 어떤 객체보다 가장 먼저 생성되는 특수 객체이다.
전역 객체를 가리키는 식별자는 여러가지가 있었으나 ES11을 기준으로 `globalThis`로 통일되었다.
```

## 2. 전역 변수의 문제점
전역 변수를 선언하는 이유는 코드 어디서든 참조하고 할당할 수 있도록 하기 위함이다.

- `암묵적 결합`
  - 선언부가 멀리 떨어질 수 있기 때문에 코드의 가독성이 나빠진다.

- `긴 생명 주기`
  - 생명 주기가 길기 때문에 메모리를 오랜 기간 소비한다.
  - 의도치 않게 변수의 상태가 변경될 위험이 크다.(변수의 재선언 등...)

- `스코프 체인 상에서 종점에 존재`
  - 스코프 체인 상에서 마지막에 존재하기 때문에, 전역 변수는 가능한 가장 마지막에 검색된다. 즉 느리다.

- `네임스페이스 오염`
  - 무분별하게 전역 변수를 사용하면, 글로벌 영역이 오염되기 때문에 변수 이름을 짓기가 점점 어려워 진다. 또한 파일이 분리되었더라도, 같은 이름으로 선언된 전역 변수가 있다면 예상치 못한 결과가 일어날 수 있다.

## 3. 전역 변수의 사용을 억제하는 방법
변수의 스코프는 가능한 좁을수록 좋다. 위와 같은 문제로 무분별한 전역변수의 사용은 좋지 않기 때문에 전역 변수를 억제하는 방법을 알아보자.

### 3.1. 즉시 실행 함수
함수 정의와 동시에 호출되는 즉시 실행 함수를 사용하면 함수 내부에서 사용한 변수는 지역변수가 된다.

```js
(() => {
  var foo = 10;
})();
```

### 3.2. 네임스페이스 객체
전역에 네임스페이스 역할을 담당할 객체를 생성하여 객체의 프로퍼티로 추가하는 방법.

```js
var MYAPP = {};

MYAPP.lname = 'kim';

console.log(MYAPP.lname); // kim
```

### 3.3. 모듈 패턴

메소드를 포함한 객체를 반환하는 함수를 IIFE로 실행한다. 메소드를 실행하면 클로저 원리에 의해 IIFE 내부에 정의한 변수에 접근하여 결과를 반환하는 구조다.

- 전역 변수의 억제와 함께 캡슐화까지 구현할 수 있다.
```
캡슐화

객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 메서드를 하나도 묶는 것.
```

- 모듈의 지역변수 혹은 특정 함수는 반환된 객체의 메소드만이 접근할 수 있다. 즉, 지역변수 혹은 중첩할수를 숨기기 위해서도 사용하는데 이를 `은닉화`라고 한다.
- 객체로 반환된 지역변수 혹은 메소드는 외부에 노출되기 때문에 퍼블릭 멤버라고 하며, 외부에 노출되지 않은 지역변수 혹은 함수는 프라이빗 멤버라고 한다.
```js
var Counter = (function (){
  var num = 0;
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  }
}());
```

### 3.4. ES6 모듈
ES6에서는 `모듈스코프`를 독자적으로 제공한다. 즉 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니다. `type="module"` 어트리뷰트를 추가하면 자바스크립트 파일은 모듈로서 동작한다.

```html
<script type="module" src="lib.mjs"></script>
```

ES6 모듈은 IE를 포함한 구형 브라우저에서는 동작하지 않는다. 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 떄문에 아직은 webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.