
1. 클래스기반의 객체프로그래밍은 기획이 바꼈을 때 코드를 확바꿔야함. 그래서 o.__proto__ 를 제공하기 시작함. 왜 제공했는가?

2. 속성이라는 단어는 쓰지말자. (프로퍼티/ 어트리뷰트) 모두 속성으로 번역된다.

3. enumerable 열거 가능한가?(순회가 아닌 열거인 이유가 있다.)

4. in 은 상속을 고려한다.
하지만 Object.prototype의 프로퍼티들이 열거되지 않는 이유는 `enumerable`이 false로 설정되어 있기 때문.
```js
const o = { a: 1, b: 2 }
for (const key in o) {
  console.log(key);
}
```

5. 식별자는 스코프에 등록된 이름, 즉, 프로퍼티 키는 식별자가 아니다.

6. get은 데이터 프로퍼티를 참조해서 특수한 값을 반환하기 위한 메서드를 대체하는 방식이라고 볼 수 있다.

7. set은 데이터 프로퍼티에 값을 할당하는 특수한 메서드인데 `=`을 통해 값을 할당할 수 있다.

8. get 접근자 프로퍼티를 사용하는 이유: 인수가 필요없는 경우 매개변수로 어떤 인수를 줘야할지 걱정할 필요가 없다.

9. get, set는 실제로 함수일 지라도 겉으로는 이미 값이 할당된 프로퍼티를 접근하는 것과 같기 때문에, 이름은 동사형이 아닌 명사형으로 짓는다.

10. 내부슬롯은 실제로 c++ 객체로 가지고 있다. 다만 getOwnPropertyDescriptor로 프로퍼티 어트리뷰트를 살펴보면, 객체 `{}` 형태로 반환해준다.

----
# 생성자 함수

11. Object.freeze(읽기)는 활용빈도가 높다.

12. `new`는 연산자다. new를 사용하면 새로운 객체를 값으로 반환하기 때문

13. `new Object()`는 객체를 생성하는 방법으로 사용하지는 않는다.(리터럴이 더 편하기 떄문).

14. Object.hasOwnProperty 등의 빌트인 함수(객체)의 메서트를 사용하기 위해서 사용한다.

15. `new String('LEE');`는 별로 사용할 이유가 없다. 우리가 사용하는게 아니라. `'LEE'.~~`를했을 때 wrapper 객체가 자동으로 `'LEE'`를 인수로 넘겨주어 임시로 객체형태로 만든다.

17. `o.getA()` getA는 메서드로써 호출되었다. this는 메서드를 호출하는 객체화 바인딩된다.

18. `Foo()` 일반함수로써 호출되어다. this는 전역객체.

19. `new Foo()` 생성자함수로써 호출되었다.

20. 생성자함수를 파스칼케이스로 사용하는 이유=>**생성자함수로 사용해라**라는 의미

21. this는 동적으로 결정된다.(함수가 호출될때) 1. 일반함수(전역객체) 2. 생성자함수(생성할 인스턴스) 3. 메서드(호출한 객체)

22. 생성자 함수로 생성한 객체를 출력해보면 `Person {}` 생성자함수가 인스턴스 정보와 함께 출력된다.

23. 생성자 함수가 호출됐을 때 js엔진은 처음에 암묵적으로 this에 미래에 생성할 객체(빈객체:`{}`)를 할당한다.

24. jds엔진은 this에 동적으로 프로퍼티를 추가하고, 마지막으로 생성된 객체를 암묵적으로 반환한다.

25. 함수가 호출될때는 실제로는 내부 메서드 `[[call]]`을 호출한다.

26. 함수중에 non-constructor인 함수는 생성자함수로서 호출될 수 없다.(es6 메서드 축약 표현, 에로우 함수)

27. 방어코드로, `new.target` 와, `instanceof` 연산자를 사용할 수 있다.

28. 일관성이 없는 문법은 사용하지 말자. ex) `String('Lee');` 문법은 클래스 생성자로 사용하도록 파스칼 케이스를 사용했다. 하지만 일반 함수로 호출했다.

29. 일급시민(모든 권리가 있다.)

30. 일급객체(면접질문) 객체와 같은 권리를 가지고 있다.

31. 일급객체가 지원되면 함수형 언어이다. 왜냐하면 함수에게 함수를 인수로 넘겨줄 수 있기 때문에.

32. 함수형 프로그래밍은 리엑트가 부상하며 함께 떠오른 패러다임이다. 일급객체는 함수형 프로그래밍과 매우 연관이 높기 때문에 중요하다.

33. 질문을 들었을 때, 키워드를 떠올려서 핵심만 답변할 수 있게 연습해라(축약). => 면접시 지루하기때문

34. 자유변수(은닉된 변수)를 조절하는 녀석을 클로저라고 한다.

35. 클로저는 자유변수의 상태를 변화할 수 있는 권한을 준 유일한 함수.(안정성)

36. 에러가 발생했을 때 함수 내부에서 에러가 발생하면 외부를 caller 프로퍼티로 접근해서 에러를 발생시킨다.

37. 모든 객체는 [[Prototype]]이라는 내부슬롯을 가지고 있다. 이 내부슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다. 즉 `__proto__`는 생성자함수의 prototype을 가리킨다.

