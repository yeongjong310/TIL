# ch 24. 클로저
- 함수를 일급객체로 취급하는 언어는 모두 클로저를 지원한다.
- 함수는 태어나는(정의가 평가) 위치가 상위 스코프로 결정된다.(렉시컬 스코프)
- 클로저(넓은 의미의)는 함수와 그 함수(자신의 스코프)가 선언된 렉시컬 환경(상위 스코프)의 조합이다.
- 이론적으로 Js의 함수는 기본적으로 모두 클로저다. 함수는 (`[[Environment]]`)에 의해 상위 렉시컬 환경까지 참조할 수 있기 때문이다.

- inner가 반환되면 innerFunc 식별자가 inner 함수를 가리킨다. 이때 innerFuc가 가리키는 inner 함수의 `[[Environment]]`가 상위 스코프(outer 렉시컬 환경)을 가리키고 있기 때문에 가비지콜렉터의 대상이 되지 않는다.
- 이때 console.log(x)에 식별자 x를 자신의 렉시컬 환경인(inner)에서 찾지 못하기 때문에 상위 렉시컬 환경으로 올라가 x를 참조한다.

    ```js
    const x = 1;

    // ①
    function outer() {
      const x = 10;
      const inner = function () { console.log(x); }; // ②
      return inner;
    }

    // outer 함수를 호출하면 중첩 함수 inner를 반환한다.
    // 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
    const innerFunc = outer(); // ③
    innerFunc(); // ④ 10
    ```
- 실질적인(좁은 의미의) 클로저 => 중첩함수가 외부함수보다 오래살아남아야 한다. 그리고 내부함수가 외부함수(상위 스코프)의 식별자를 하나라도 보고 있어야 한다.

- 함수가 일급객체여야한다. 함수가 상위 스코프를 들고있어야 한다.

- mark and sweep에 렉시컬환경에 전역에서 부터 참조하지 못하면,

- 왜 글로벌 렉시컬 환경이 사라지지 않는가?

- 최적화의 관점에서 bar가 foo보다 오래 살아남아도 상위 스코프의 식별자를 참조하지 않기 때문에 클로저라고 보지는 않는다.
```js
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 일반적으로 클로저라고 하지 않는다.
      function bar() {
        const z = 3;

        debugger;
        // 상위 스코프의 식별자를 참조하지 않는다.
        console.log(z);
      }

      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```

- 캡슐화와 정보은닉의 차이..?

- 즉시실행함수는 외부 함수가 실행되는 순간 외부함수가 종료된다. 그리고 반환된 함수가 더 오래살아남았다. 이떄 반환된 함수를 외부에서 호출하면 클로저(반환된 함수)가 상위 스코프의 변수를 상태변화시킬 수 있다.
  - 즉 클로저만이 상태변화를 시킬수 있으므로, 안전하게 상태를 변화시킬 수 있다.

- 상위스코프의 변수를 자유변수라고 한다. 자유변수는 클로저만 상태변경시킬 수 있다.

```js
const counter = (function () {
  // 카운트 상태 변수
  let num = 0; // 자유변수

  // 클로저인 메서드를 갖는 객체를 반환한다.
  // 객체 리터럴은 스코프를 만들지 않는다.
  // 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.
  return {
    // num: 0, // 프로퍼티는 public하므로 은닉되지 않는다.
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    }
  };
}());

console.log(counter.increase()); // 1
```

- 객체로 위와같은 방식으로 구현할 경우 프로퍼티를 외부에서 상태변화시킬수 있다. 안전하지 않다.

- makeCounter 의 경우 렉시컬 환경이 2개 만들어진다. 이렇게 코딩된 이유는 고차함수가 외부에서 콜백함수를 받기 때문이다. 이것을 즉시실행함수로 구조를 바꿔야 한다.


## 21.5.28 금

- 객체지향에서는 this를 신경써야하지만, 함수형프로그래밍은 closure를 신경서야한다. 리엑트가 객체지향(class)에서 함수형프로그래밍으로 돌아섰다. 즉, this -> closure로 갈아탔다. 리엑트 훅이 전부 closure방식이기 때문에 왜 훅이 이렇게 돌아가는가를 이해하려면 closure를 알아야 한다.

- 빨리가 아니라 코드를 작성할 떄 하나라도 깨달을 수 있는 것이 중요하다.

- **클로저는 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 외부 함수 밖에서 중첩 함수를 호출하더라고 외부 함수의 지역 변수에**


### 5. 캡슐화와 정보 은닉
- Js는 캡슐화를 했을 때 모든 프로퍼티가 public 이다.
- **결합도는 낮고, 응집도는 높아야한다.**
  - 결합도가 높다는 의미는, 하나의 객체가 다른 객체의 영향을 받게되어, 다른 객체가 변경되었을 때 다른 하나의 객체가 영향을 받아 문제가 될 수 있다.
  - 