# 점화식
점화식은 점점 어떠한 수를 만들어가는 하나의 식이다.
예를들어 `등차수열인 a(n)`이라는 말은 a(n)이 이미 등차수열로 결정되었음을 알 수 있지만,
`a(n+1) = a(n) + d` 라는 말은 이 식만 보고 등차수열인지 바로 알 수 없다.
따라서 a(1)이 1이고, d가 1일 때 위의 식을 구하는 과정은 다음과 같다.

```
a(2) = a(1) + 1 // 2
a(3) = a(2) + 1 // 3
a(4) = a(3) + 1 // 4
```
하나의 항을 알아내기 위해서 그 주변의 항들을 이용해야 한다. 그리고 하나씩 다음 항을 알아가다보면 결국 이 식이 등차수열을 나타내고 있음을 인지할 수 있다.
그리고 위의 식을 다음과 같이 표현할 수도 있다.
>a(n) = a(1) + (n-1)*1

## 점화식의 중요성
이제 점화식이 왜 중요한지 알아보자. 프로그래밍을 하면, 언젠가 반복되는 과정이 생긴다. 그리고 for문을 이용해 그 반복과정을 처리한다.
만약 위의 예제와 같은 반복문을 처리해야한다고 생각해보자.
```
// a(n) = a(1) + (n-1)*1 점화식 풀이
function A(n) {
  let a1 = 1;
  if (n > 1) {
    return A(n-1) + 1
  } else 
    return a1
}

console.log(A(4)); // 4
```

```
// a(n) = a(1) + (n-1)*1 방식 풀이
function A(n) {
  let a1 = 1;
  return a1 + n-1
}
console.log(A(4)); // 4
```

점화식 풀이는 시간복잡도가 O(n)인 반면 다른 풀이는 O(1)이다. Wow..
어떤 반복과정을 처리할 때 점화식 관계를 파악하고 시간복잡도를 줄일 수 있다.

## 대표적인 점화식
### 등차수열
```
a(n+1) - a(n) = d
a(n+1) = a(n) + d
a(n+2) + a(n) = 2a(n+1)
```
### 등비수열
```
a(n+1) = a(n) * r
a(n+1) / a(n) = r
a(n+1)^2 = a(n) * a(n+2)
a(n) = a(1) * r^(n-1)
```
등비수열의 합
```
r * S(n) =      a(1) * r + a(1) * r^2 ... a(1) * r^n-1 + a(1) * r^n
- S(n) = a(1) + a(1) * r + a(1) * r^2 ... a(1) * r^n-1
=
(r-1)S(n) = a(1) * r^n - a(1)
=
S(n) = a(1)(r^n-1) / r-1
```

![image](https://user-images.githubusercontent.com/39623897/107609979-c8c80780-6c83-11eb-90b1-7031bd1911db.png)


### 계차수열
```
a(n+1) - a(n) = b(n)
a(n) = a(1) + Σ(k=1 ~ k=n-1)b(k)
```
### 계비수열
```
a(n+1) = a(n) * b(n)
a(n) = a(1)*π(k=1 ~ k=n-1)b(k) (π는 각 항의 곱)
```

```
a(2) = a(1) * b(1)
a(3) = a(2) * b(2)
.
.
.
a(n) = a(n-1) * b(n-1)
```
모든 변을 곱하면 

~~a(2)~~ * ~~a(3)~~ ...* a(n) = a(1) * ~~a(2)~~ ... * ~~a(n-1)~~ * b(1) * b(2) ... b(n-1)

결국 다음과 같은 식이된다.

> a(n) = a(1) * b(1) * b(2) ... b(n-1)

그리고 b(n) = 3^n 이라면 다음 식과 동일해 진다.
> a(n) = a(1)*3^((n * n-1)/2)

### 귀납적 점화식 유형 1번
>a(n) = p * a(n-1) + q

일반식을 구하는 2가지 방법

1번
```
a(n) + c = p(a(n-1) + c) 형식으로 바꿀 수 있다.
a(n) + c = b(n) 으로 치환하여 b(n)이 등비수열임을 인식한다.
b(n) = p * b(n-1)
b(n) = b(1) * p^(n-1)
a(n) + c = (a(1) + c) * (p^(n-1))
a(n) = (a(1) + c) * (p^(n-1)) - c
```

2번
```
  a(n+1) + c = p(a(n) + c)
- a(n)   + c = p(a(n-1) +c)
-----------------------------
a(n+1) - a(n) = p(a(n) - a(n-1))

이번에는 a(n+1) - a(n)을 b(n)으로 치환해 보자.
b(n+1) = p * b(n) 이기 때문에 b(n)은 등비수열이다.
또한 b(n)이 인접한 a항의 차이기 때문에 a(n)은 p를 등비로하는 계차를 가진 계차 수열이 된다.
그렇다면 계차수열 공식을 적용해보자.

a(n) = a(1) + Σ(k=1 ~ k=n-1)b(k)
a(n) = a(1) + Σ(k=1 ~ k=n-1)b(1) * p^k - 1
a(n) = a(1) + b(1) * (p^n - 1) / (p - 1)
a(n) = a(1) + (a(2)-a(1)) * (p^n - 1) / (p - 1)
```

예제

> 1, 4, 13, 40 .... 인 수가 있다. 100번 째 수는 무엇일까?
풀이
```
a(n + 1) = a(n) + b(n)
b(n) = 3^n
a(n + 1) = a(n) + 3^n

a(n) = a(1) + Σ(k=1 ~ k=n-1)3^k
a(n) = 1 + 3(3^(n-1) - 1)/(3 - 1)
a(100) = 1 + 3(3^100 - 1)/(3 - 1) 이 된다. 
```

예제 2. 2018년도 3월 고3 수학모의고사 나형 26번

![image](https://user-images.githubusercontent.com/39623897/107618768-77287880-6c95-11eb-99cc-2a3a7b321e38.png)

풀이
```
a(1)이 6이기 때문에 1번째 조건을 만족한다. 따라서  
   a(2) = 2 - a(1)
=> a(2) = 2 - 6 = -4

a(2)가 -4이기 때문에 2번째 조건을 만족한다. 따라서
   a(3) = a(2) + p
=> a(3) = -4 + p

이때 a(3)이 0 보다 크거나 같은지 작은지 모르기 때문에 두 식 모두 적용해 본다.

1. a(3) >= 0 경우
a(4) = 2 - a(3)
a(4) = 2 - (-4 + p)
a(4) = 6 - p
a(4) 는 0 이기 때문에 p 는 6이 된다.

2. a(3) < 0 인 경우
a(4) = a(3) + p
a(4) = -4 + p + p
0 = -4 + 2p
2 = p

즉 p는 2 or 6이기 때문에 모든 p의 합은 8이다.
```
